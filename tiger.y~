%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "tabela.h"
#include "absyn.h"
#include "semantico.h"

#include "y.tab.h"
int yydebug = 1; 
//absyn_exp* ast;
extern int tokpos;
extern int col;
/* Declarações para fazer interface entre o lexer e este arquivo, são compartilhadas entre o código do lex e yacc */
extern int yylex();
extern int yyparse();
extern FILE *yyin;
extern int posAtual;
extern int lin;      /* conta as linhas */
extern int col;      /* conta as colunas */
extern char* yytext; /* valor do token na entrada */
extern int yyval;    /* valor de variaveis, atribuído no .l */

Exp_n* astRoot; /** Árvore de derivação */

Tabela* tab; /** Tabela de simbolos */


void yyerror(const char *str)
{
    fprintf(stderr, "\n*** Erro de sintaxe: linha %i, coluna %lu, token '%s' ***\n\n", lin, col - strlen(yytext), yytext);
    exit(EXIT_FAILURE);
}

int yywrap() { return 1; }

%}

/* 
https://stackoverflow.com/questions/43882160/bison-grammar-type-and-token
palavras chave dessa seção
https://www.ibm.com/docs/en/aix/7.2?topic=information-yacc-grammar-file-declarations
*/
%union //tipos dos tokens
{
    int intVal; //acessível por yyval.intVal 
    char* strVal;
    
    Exp_n* exp, expList;
    
    Var_n* var;
    Dec_n* dec, decList, varDec, tyDec, funDec, argsDec;
    Tipo_n* tid, ty, tyList;
}

/*%type 	Identifies the type of nonterminals. Type-checking is performed when this construct is present. */
/* para checar tipos, usar %type , quando declarado o token na forma
%type <tag> nome [numero] [...]
para chegar tipos, o yacc testa se nome é do mesmo tipo de tag: uma variável presente na %union acima
em %type, a tag é obrigatória ; nas outras %keywords, ela é opcional
*/

/* POSIX yacc reserves %type to nonterminals  protanto para os terminais usar diretamente em %token */
//tipos retornados pelos não terminais em $n através de $$

%token <intVal> NUM
%token <strVal> STRING
%token <exp> NIL
// tipos de nao terminais 

%type <exp> exp
%type <expList> expseq expseq1
%type <var> lvalue typeid
%type <dec> dec
%type <decList> decs 
%type <varDec> vardec
%type <tyDec> tydec
%type <funDec> fundec
%type <argsDec> args args1
%type <tid> tid
%type <ty> ty
%type <tyList> tyfields tyfields1 


%token ABREPAR FECHAPAR ABRECHAV FECHACHAV ABRECOL FECHACOL MENOS MAIS VEZES DIVIDIR IGUAL DIFERENTE MENOR MENORIG MAIOR MAIORIG E OU OF ATRIBUI IF THEN ELSE WHILE DO FOR TO BREAK LET IN END TIPO DOISPONTOS VAR FUNCTION PONTO PONTOVIRG VIRG ID ARRAY
/*%token ABREPAR FECHAPAR ABRECHAV FECHACHAV ABRECOL FECHACOL MENOS MAIS VEZES DIVIDIR IGUAL DIFERENTE MENOR MENORIG MAIOR MAIORIG E OU OF ATRIBUI IF THEN ELSE WHILE DO FOR TO BREAK LET IN END TIPO DOISPONTOS VAR FUNCTION PONTO PONTOVIRG VIRG ID <intVal> NUM STRING ARRAY*/

%nonassoc OF IF THEN WHILE DO FOR TO ATRIBUI TIPO FUNCTION          /* menor precedencia */
%nonassoc OU
%nonassoc E
%nonassoc IGUAL DIFERENTE MAIOR MENOR MAIORIG MENORIG 
%left MAIS MENOS /* MENOS unário deve ter maior precedencia de todos*/
%left VEZES DIVIDIR
%left ELSE                                                          /*  maior precedencia */

/* ver para proxima parte */
/*https://www.gnu.org/software/bison/manual/html_node/Union-Decl.html*/
/*https://www.classes.cs.uchicago.edu/archive/2003/spring/22600-1/docs/lexyacc.pdf*/

%start inicio

%%

inicio : exp                            { printf("inicio \t-> exp\n"); chk_Exp($1, 1); astRoot=$1; };


exp : lvalue                            { printf("exp \t-> lvalue\n"); chk_Var($1, 1);  } 
|     NIL                               { printf("exp \t-> NIL()\n"); chk_Exp($1, 1);  /** Term*/}
|     ABREPAR expseq FECHAPAR           { printf("exp \t-> ( expseq )\n");  /** Term*/}
|     NUM                               { printf("exp \t-> NUM(%d)\n", yylval.intVal); chk_Const(&($1), int_t, col); /** Term*/}
|     STRING                            { printf("exp \t-> STRING(%s)\n", yytext);   /** Term*/}
|     MENOS exp                         { printf("exp \t-> - exp\n"); }
|     ID ABREPAR args FECHAPAR          { printf("exp \t-> ID ( args )\n"); } //call
|     exp MAIS exp                      { printf("exp \t-> exp + exp\n"); } //op inicio
|     exp MENOS exp                     { printf("exp \t-> exp - exp\n"); }
|     exp VEZES exp                     { printf("exp \t-> exp * exp\n"); }
|     exp DIVIDIR exp                   { printf("exp \t-> exp / exp\n"); }
|     exp IGUAL exp                     { printf("exp \t-> exp = exp\n"); }
|     exp DIFERENTE exp                 { printf("exp \t-> exp <> exp\n"); }
|     exp MENOR exp                     { printf("exp \t-> exp < exp\n"); }
|     exp MAIOR exp                     { printf("exp \t-> exp > exp\n"); }
|     exp MENORIG exp                   { printf("exp \t-> exp <= exp\n"); }
|     exp MAIORIG exp                   { printf("exp \t-> exp >= exp\n"); }
|     exp E exp                         { printf("exp \t-> exp & exp\n"); }
|     exp OU exp                        { printf("exp \t-> exp | exp\n"); }      //op fim
|     tid                               { printf("exp \t-> tid\n"); } /*modificação aqui*/
|     lvalue ATRIBUI exp                { printf("exp \t-> lvalue := exp\n"); }
|     IF exp THEN exp ELSE exp          { printf("exp \t-> IF exp THEN exp ELSE exp\n"); }
|     IF exp THEN exp                   { printf("exp \t-> IF exp THEN exp\n"); }
|     WHILE exp DO exp                  { printf("exp \t-> WHILE exp DO exp\n"); }
|     FOR ID ATRIBUI exp TO exp DO exp  { printf("exp \t-> FOR ID := exp TO exp DO exp\n"); }
|     BREAK                             { printf("exp \t-> BREAK\n"); }
|     LET decs IN expseq END	        { printf("exp \t-> LET decs IN expseq END\n");  };

tid:  
      ABRECHAV  ID IGUAL exp idexps FECHACHAV { printf("tid \t-> typeid { ID = exp idexps }\n");}
|     ABRECOL  exp FECHACOL OF exp     { printf("tid \t-> typeid [ exp ] OF exp\n");};



decs :
    dec decs                            { printf("decs \t-> dec decs\n");}
    |                                   { printf("decs \t-> ''\n");};

dec : 
      tydec                             { printf("dec \t-> tydec\n");}
|     vardec                            { printf("dec \t-> vardec\n");}
|     fundec                            { printf("dec \t-> fundec\n");};

tydec : 
    TIPO ID IGUAL ty                    { printf("tydec \t-> TYPE ID = ty\n");};

ty : 
      ID                                { printf("ty \t-> ID\n");}                        
|     ABRECHAV ID DOISPONTOS typeid tyfields1 FECHACHAV { printf("{ ty \t-> ID : typeid tyfields1 }\n");} 
|     ARRAY OF ID                       { printf("ty \t-> ARRAY OF ID = ty\n");};

tyfields : 
    ID DOISPONTOS typeid tyfields1      { printf("tyfields \t-> ID : typeid tyfields1\n");}
    |                                   { printf("tyfields \t-> ''\n");};

tyfields1 : 
    VIRG ID DOISPONTOS typeid tyfields1 { printf("tyfields1 \t-> , ID : typeid tyfields1\n");}
    |                                   { printf("tyfields1 \t-> ''\n");};

vardec : 
     VAR ID ATRIBUI exp                 { printf("vardec \t-> VAR ID := exp\n");} 
|    VAR ID DOISPONTOS typeid ATRIBUI exp { printf("vardec \t-> VAR ID : typeid := exp\n");};

fundec : 
    FUNCTION ID ABREPAR tyfields FECHAPAR IGUAL exp { printf("fundec \t-> FUNCTION ID ( tyfields ) = exp\n");} 
|   FUNCTION ID ABREPAR tyfields FECHAPAR DOISPONTOS typeid IGUAL exp { printf("fundec \t-> FUNCTION ID ( tyfields ) : typeid = exp\n");} ;

lvalue : 
    ID                                  { printf("lvalue \t-> ID\n");}
|   lvalue PONTO ID                     { printf("lvalue \t-> lvalue . ID\n");}
|   lvalue ABRECOL exp FECHACOL        { printf("lvalue \t-> lvalue [ exp ]\n");}
;


typeid : 
    ID                                  { printf("typeid \t-> ID()\n");};

expseq : 
    exp expseq1                         { printf("expseq \t-> exp expseq1\n");}
    |                                   { printf("expseq \t-> ''\n");};  

expseq1 :
    PONTOVIRG exp expseq1               { printf("expseq1 \t-> ; exp expseq1\n");}
    |                                   { printf("expseq1 \t-> ''\n");};

args : 
    exp args1                           { printf("args \t-> exp args1\n");}
    |                                   { printf("args \t-> ''\n");}; 

args1 : 
    VIRG exp args1                      { printf("args1 \t-> , exp args1\n");}
    |                                   { printf("args1 \t-> ''\n");}; 

idexps : 
    VIRG ID IGUAL exp idexps            { printf("idexps \t-> , ID = exp idexps\n");}
    |                                   { printf("idexps \t-> ''\n");};

%%

int main(int argc, char** argv)
{
    if(argc != 2)
    { 
        printf("Erro nos arquivos de entrada.\nModo de usar: >%s arquivo_fonte.tig\n", argv[0]); 
        return 1;
    }
    
    yyin = fopen(argv[1], "r");
    if (yyin == NULL) 
    {
        printf("Erro ao abrir arquivo fonte.\n");
        return -1;
    }
    
    /*char c = fgetc(yyin);
    printf("Listagem do código fonte:\n");
    while (c != EOF)
    {
        printf ("%c", c);
        c = fgetc(yyin);
    }
    rewind(yyin);*/
    
    //while(yylex()) printf("%s\n", yytext); ;
    //printf("Listagem das regras de derivação para acompanhamento:\n");
    yyparse(); //fica chamando o yylex(), vulgo "pedindo tokens"
    //printf("\nACEITO!\n"); // linguagem reconhecida
    
    fclose(yyin);
    Tabela* t = T_init(); 
    T_entrar_bloco(t); //conforme aula 17 min 30 ; slide comp-06
    T_sair_bloco( t);

    T_checar_existencia(t,  "nome");

 //T_instalar( t, "nome1", 89);
 //T_instalar( t, "nome2", 55);
 //T_instalar( t, "nome3", 22);
//T_imprimir( t);
T_delete( t);
    return 0;
}

/*
Fez a análise Semântica completa [S, N, Mais ou Menos] (4 pontos)
• Gerou código intermediário para declarações [S, N, Mais ou Menos] (3 pontos)
• Gerou código intermediáriopara comandos [S, N, Mais ou Menos] (3 pontos)
• Gerou código intermediário para expresses [S, N, Mais ou Menos] (2 pontos)
• EXTRA - 3 pontos
• Apresentou os resultados da execução do(s) programas testes (convincentes) submetido(s) ao Com-
pilador [S, N, Mais ou Menos] (2 pontos)
• Apresentou as listagens dos programas fontes submetido(s) ao Compilador? [S, N, Mais ou Menos]
(1 pontos

*/
